1. find if path exist

class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        unordered_map<int,vector<int>> graph;
        for(auto e: edges){
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
        }
        vector<bool> visited(n,0);
        queue<int> q;
        q.push(source);
        visited[source]=1;
        while(!q.empty()){
            int curr= q.front();
            q.pop();
            if (curr==destination) return true;
            for (auto node: graph[curr]){
                if (!visited[node]){
                    visited[node]=1;
                    q.push(node);
                }
            }
        }
        return false;
    }
};

2. print all path from source to destination 

class Solution {
public:

    void dfs(int curr, vector<vector<int>>&paths, vector<int> &path, vector<vector<int>>& graph){
        path.push_back(curr);
        if(curr==graph.size()-1) paths.push_back(path);
        else for(auto nbrs: graph[curr]){
            dfs(nbrs, paths,path,graph);
        }
        path.pop_back();
    }

    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        vector<vector<int>>paths;
        vector<int> path;
        dfs(0,paths,path,graph);
        return paths;
    }
};

3. number of island

class Solution {
public:

    void dfs(vector<vector<char>>& grid, int i, int j){
        if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size()) return;
        if (grid[i][j]=='0' || grid[i][j]=='2') return;
        grid[i][j]='2';
        dfs(grid,i+1,j);
        dfs(grid,i,j+1);
        dfs(grid,i-1,j);
        dfs(grid,i,j-1);
    }

    int numIslands(vector<vector<char>>& grid) {
        int island=0;

        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[0].size();j++){
                if(grid[i][j]=='1'){
                    island++;
                    dfs(grid,i,j);
                }
            }
        }
        return island;
    }
};
