1. Generate Parentheses

class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def dfs(left,right,s):
            if (len(s)==n*2):
                res.append(s)
                return
            if (left<n):
                dfs(left+1,right,s+'(')
            if (right<left):
                dfs(left,right+1,s+')')
        res=[]
        dfs(0,0,'')
        return res

2. Subset-2

class Solution {
public:

    void makesubs(int ind, vector<int>& nums, vector<vector<int>>& ans, vector<int>& ds){
        ans.push_back(ds);
        for (int i=ind; i<nums.size();i++){
            if(i!=ind && nums[i]==nums[i-1]) continue;
            ds.push_back(nums[i]);
            makesubs( i+1, nums, ans, ds);
            ds.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> ans;
        vector<int> ds;
        sort(nums.begin(),nums.end());
        makesubs(0, nums, ans, ds);
        return ans;
    }
};

3. Sudoku Solver

class Solution {

    int n=3, N=9;
    int rows[9][10]={}, cols[9][10]={}, boxes[9][10]={};
    vector<vector<char>>* boardPtr;
    bool sudokuSolved = false;

    bool canPlace(int d, int row, int col){
        int idx = (row/n)*n + col/n;
        return rows[row][d] + cols[col][d] + boxes[idx][d]==0;
    }

    void place(int d , int row, int col){
        int idx = (row/n)*n + col/n;
        rows[row][d]++;
        cols[col][d]++;
        boxes[idx][d]++;
        (*boardPtr)[row][col] = d + '0';
    }

    void remove(int d, int row, int col){
        int idx = (row/n)*n + col/n;
        rows[row][d]--;
        cols[col][d]--;
        boxes[idx][d]--;
        (*boardPtr)[row][col] = '.';
    }

    void placeNext(int row, int col){
        if (row== N-1 && col==N-1) sudokuSolved = true;
        else if (col==N-1) backtrack(row+1,0);
        else backtrack(row,col+1);
    }

    void backtrack(int row, int col){
        if ((*boardPtr)[row][col]=='.'){
            for (int d=1;d<=9;d++){
                if (canPlace(d,row,col))
                    {
                        place(d,row,col);
                        placeNext(row,col);
                        if (!sudokuSolved) remove(d,row,col);
                    }
                }
            }
        else placeNext(row,col);
        }
    
    public:
    void solveSudoku(vector<vector<char>>& board) {
       boardPtr= &board;
       for (int i=0;i<N;i++){
        for (int j=0;j<N;j++){
            if(board[i][j] != '.') place(board[i][j] - '0', i, j);
        }
       }
        backtrack(0,0);
    }
};
